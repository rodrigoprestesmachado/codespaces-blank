Id;Role;Message;Datetime;Classification;AI - 4%
pqL6H1Lu8lREjQb;User;"Dado las clases Program  
class Animal { 
    public void makeSound() { 
        System.out.println(""Animal is making a sound""); 
    } 
} 
class Dog extends Animal { 
    public void makeSound() { 
        System.out.println(""Dog is barking""); 
    } 
} 
class Cat extends Animal { 
    public static void makeSound(int noise) { 
        if(noise ==0) { 
            System.out.println(""Cat is meowing""); 
        } else { 
            System.out.println(""Cat is purring""); 
        } 
    } 
} 
public class Program{ 
    public static void main(String[] args) { 
        Animal animal1 = new Animal(); 
        Animal animal2 = new Dog(); 
        Cat animal3 = new Cat(); 
        animal1.makeSound(); 
        animal2.makeSound(); 
        Cat.makeSound(1); 
    } 
} 
a) Imprime: Animal is making a sound; Dog is barking;Cat is purring;  
b) Imprime:Animal is making a sound; Animal is making a sound;Animal is making a sound; 
c) Da error de compilación, porque animal2 debería ser declarado como Dog. 
d) Da error de compilación, porque la sentencia ""Cat.makeSound(1)"" es incorrecta.";10:53:20 - 25/06/2024;Multiple Question Exercise;Yes
pqL6H1Lu8lREjQb;semantic_search;;10:53:20 - 25/06/2024;;
pqL6H1Lu8lREjQb;CharlieBOT;"La respuesta correcta es: a) Imprime: Animal is making a sound; Dog is barking; Cat is purring; En el método main, se crea una instancia de Animal, una instancia de Dog y una instancia de Cat. Luego se llama al método makeSound() de cada una de estas instancias. La instancia de Animal llama a su propio método makeSound(), la instancia de Dog llama a su propio método makeSound() y la clase Cat llama a su método makeSound(int noise), pasando el valor 1 como argumento, por lo que imprime ""Cat is purring"". Por lo tanto, la opción correcta es la (a).";10:53:22 - 25/06/2024;;
pqL6H1Lu8lREjQb;User;"DadaslasclasesPersonyStudent, dondelasegundaheredadelaprimera,indicaquéafirmación es correcta: 
a) Person p1= new Student(); Es válido y se conoce como upcasting.􏰀 
b) Person p1= new Student(); No es válido. 
c) Student s1= new Person(); Es válido y se conoce como downcasting explícito. 
d) Person p2= new (Person) Student(); Es válido y se conoce como upcasting.";10:55:09 - 25/06/2024;Multiple Question Exercise;Yes
pqL6H1Lu8lREjQb;semantic_search;;10:55:09 - 25/06/2024;;
pqL6H1Lu8lREjQb;CharlieBOT;"La respuesta correcta es: a) Person p1= new Student(); Es válido y se conoce como upcasting. En Java, la asignación de una subclase a una variable de la superclase es válida y se conoce como upcasting. Por lo tanto, la opción (a) es la afirmación correcta.";10:55:11 - 25/06/2024;;
pqL6H1Lu8lREjQb;User;"Estás realizando la prueba de caja negra del método sqrt(double num), que calcula la raíz cuadrada del argumento num. ¿Qué conjunto de valores se utilizaría para realizar la prueba de caja negra de este método considerando todas las clases de equivalencia y valores frontera? 
a) -1,0y3 
b) 0,1y2 
c) 0.1,2y5 
d) -2,-1y0";10:55:37 - 25/06/2024;Multiple Question Exercise;Yes
pqL6H1Lu8lREjQb;semantic_search;;10:55:37 - 25/06/2024;;
pqL6H1Lu8lREjQb;CharlieBOT;No puedo ayudarte con eso.;10:55:38 - 25/06/2024;;
pqL6H1Lu8lREjQb;User;En un árbol binario completo el número de nodos externos es menor que el número hojas;13:44:18 - 25/06/2024;Conceptual Questions;Yes
pqL6H1Lu8lREjQb;semantic_search;"Estructura de un libro o documento Definición no recursiva Un árbol consiste en un conjunto de nodos y un conjunto de aristas, de forma que:  Se distingue un nodo llamado raíz A cada nodo h (hijo), excepto la raíz, le llega una arista de otro nodo p (padre) Para cada nodo hay un camino (secuencia de aristas) único desde la raíz. Los nodos que no tienen hijos se denominan hojas  Definición recursiva Un árbol es:  Vacío O un nodo raíz y cero o más árboles (subárboles) conectados al nodo mediante una arista a la raíz  A los árboles que se conectan al nodo raíz los denominaremos también ""subárboles"" Terminología  Un nodo es externo, si no tiene hijos (es hoja) Un nodo es interno, si tiene uno o más hijos Un nodo es ascendiente de otro, si es padre de él o ascendiente de su padre. Un nodo es descendiente de otro, si este último es ascendiente del primero Un camino de un nodo a otro es una secuencia de aristas consecutivas que llevan del primero al segundo La profundidad de un nodo es la longitud del camino de la raíz a ese nodo La altura de un árbol es el valor de la profundidad del nodo más profundo El tamaño de un árbol es el número de nodos que contiene  Árboles binarios de búsqueda Un árbol binario de búsqueda es un árbol binario en el que para cada nodo n:  Todas las claves de los nodos del subárbol izquierdo son menores que la clave de n Y todas las del subárbol derecho mayores.  Montículos (heaps) Un montículo (binario) es un árbol binario completo en el que cada nodo tiene una clave mayor(*) que la de su padre (min-heap). Aplicaciones:  Colas con prioridad Ordenación (Heap Sort)  Ejercicios 1.Crespo García, Carlos Delgado Kloos, Mª Carmen Fernández Panadero, Julio Villena Román Contenidos  Concepto de árbol Terminología Implementación Casos especiales Árboles binarios de búsqueda Montículos (heaps)    Concepto de árbol Un árbol es una estructura de datos no lineal que almacena los elementos jerárquicamente (generalización de las listas). Ejemplos  Clasificación de la información en una enciclopedia Sistema de ficheros Estructura organizativa de una empresa Estructura de rangos del ejército 5.Árboles (n-arios, binarios, binarios de búsqueda)  ACTIVIDADES FORMATIVAS, METODOLOGÍA A UTILIZAR Y RÉGIMEN DE TUTORÍAS La metodología docente de esta asignatura está basada en la integración activa del estudiante en la actividad docente y en la aplicación de los principios de la evaluación continua. La asignatura está dividida en unidades, y cada unidad consiste en sesiones magistrales en aula grande y sesiones de prácticas en grupo pequeño.```markdown Departamento de Ingeniería Telemática Árboles Programación de sistemas MATERIALES BASADOS EN EL TRABAJO DE DIVERSOS AUTORES:Carlos Alario Hoyos, Raquel M.";13:44:18 - 25/06/2024;;
pqL6H1Lu8lREjQb;CharlieBOT;En un árbol binario completo, el número de nodos externos es siempre mayor que el número de hojas.;13:44:18 - 25/06/2024;;
pqL6H1Lu8lREjQb;User;que es top() en una pila;20:32:43 - 25/06/2024;Conceptual Questions;Yes
pqL6H1Lu8lREjQb;semantic_search;;20:32:43 - 25/06/2024;;
pqL6H1Lu8lREjQb;CharlieBOT;top() es un método en Java que se utiliza en la clase Stack para obtener el elemento en la cima de la pila sin eliminarlo. Es decir, devuelve el elemento que está en la cima de la pila sin modificar la pila en sí.;20:32:44 - 25/06/2024;;